#                                                                                                                                                                                                                                     

## 浅拷贝 JSON.stringify 的弊端

```javascript
let obj = {
  name: "坤坤",
  age: 18,
  abc: undefined,
  sing: () => console.log("鸡你太美"),
  hobby: ["唱", "跳", "rap", "篮球"],
};

const newObj = JSON.parse(JSON.stringify(obj));
console.log(newObj); // {"name": "坤坤","age": 18,"hobby": ["唱","跳","rap","篮球"]}

const a = structuredClone(obj);
console.log(a);
```

可以看到,使用JSON.stringify拷贝后的数据丢失了undefined和函数类型的值，如果不考虑这两点，使用JSON.stringify是最简单的浅拷贝方式

## 手写深拷贝

```javascript
const deepClone = (params) => {
  if (typeof params !== "object" || params === null) {
    return params;
  }
  let clone = Array.isArray(params) ? [] : {};
  for (let key in params) {
    if (params.hasOwnProperty(key)) {
      clone[key] = deepClone(params[key]);
    }
  }
  return clone;
};
```
