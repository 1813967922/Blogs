# 扁平化树型对象数组

众所周知二维以上的简单类型数组可以用 flat 方法平铺，那树型对象数组类型的的数据怎么平铺呢？

## 数据准备

这种类型的数组怎么扁平化？

```javascript
const treeData = [
  {
    id: "1000",
    pid: "",
    name: "张三",
    children: [
      {
        id: "1100",
        pid: "1000",
        name: "李四",
        children: [
          {
            id: "1200",
            pid: "1100",
            name: "王五",
          },
        ],
      },
    ],
  },
  {
    id: "1001",
    pid: "",
    name: "小甲",
    children: [
      {
        id: "1999",
        pid: "1001",
        name: "小乙",
      },
    ],
  },
];
```

## 开始

先声明一个方法,接收一个参数，首先判断这个参数是不是数组，不是的话直接返回一个空数组

```javascript
const getTreeStillData = (treeData) => {
  if (!(judgeType(treeData, "Array") && treeData.length)) {
    return [];
  }
  ...
}

// 类型判断
const judgeType = (params, type) => {
  let typeStr = Object.prototype.toString.call(params);
  return typeStr.indexOf(type) != -1;
};
```

因传递的对象数组是引用传递，后面对数组的更改会导致原数据一起改变，所以这里我们克隆一份数据，使其脱离引用。

```javascript
const getTreeStillData = (treeData) => {
  if (!(judgeType(treeData, "Array") && treeData.length)) {
    return [];
  }
  let queue = new Array();
  // res用来存放平铺后的数据，并返回出去
  let res = new Array();
  queue = deepClone(treeData);
  ...
}

// 类型判断
const judgeType = (params, type) => {
  let typeStr = Object.prototype.toString.call(params);
  return typeStr.indexOf(type) != -1;
};

// 克隆
const deepClone = (params) => {

  if (typeof params !== "object" || params === null) {
    return params;
  }
  let clone = Array.isArray(params) ? [] : {};
  for (let key in params) {
    if (params.hasOwnProperty(key)) {
      clone[key] = deepClone(params[key]);
    }
  }
  return clone;
};
```

- 然后我们对克隆后的数组进行遍历，使用数组的 shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。注意此方法会改变数组的长度！
- 判断该值的 children 属性是否为 Array 类型并且长度不为 0。如果为真则使用扩展运算符把该值的 children 属性中的数据扩展到克隆后的数组中，这会增加数组的长度，可以确保后面使用 shift()方法如果还返回带有 children 属性的值时可以处理到,之后使用 delete 删除该值的 children 属性,并把该值放入用于存放平铺后数据的 res 数组中。
- 直到 for 循环不再执行，就可以把 res 数组返回出去。

## 完整代码

```javascript
// 克隆
const deepClone = (params) => {
  if (typeof params !== "object" || params === null) {
    return params;
  }
  let clone = Array.isArray(params) ? [] : {};
  for (let key in params) {
    if (params.hasOwnProperty(key)) {
      clone[key] = deepClone(params[key]);
    }
  }
  return clone;
};
// 类型判断
const judgeType = (params, type) => {
  let typeStr = Object.prototype.toString.call(params);
  return typeStr.indexOf(type) != -1;
};
// 平铺树型数据
function getTreeStillData(treeData) {
  if (!(judgeType(treeData, "Array") && treeData.length)) {
    return [];
  }
  let queue = new Array();
  let res = new Array();
  queue = deepClone(treeData);
  for (let i = 0; i < queue.length; ) {
    let item = queue.shift();
    if (judgeType(item.children, "Array") && item.children.length) {
      queue.push(...item.children);
    }
    delete item.children;
    res.push(item);
  }
  return res;
}

const treeData = [
  {
    id: "1000",
    pid: "",
    name: "张三",
    children: [
      {
        id: "1100",
        pid: "1000",
        name: "李四",
        children: [
          {
            id: "1200",
            pid: "1100",
            name: "王五",
          },
        ],
      },
    ],
  },
  {
    id: "1001",
    pid: "",
    name: "小甲",
    children: [
      {
        id: "1999",
        pid: "1001",
        name: "王五",
      },
    ],
  },
];
const data = getTreeStillData(treeData);
console.log(data);
```
